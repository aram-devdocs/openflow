/**
 * Validation Framework - Shared Type Definitions
 *
 * Core types used across all validation scripts in the OpenFlow validation suite.
 * These types ensure consistency in violation reporting, configuration, and output.
 */

// =============================================================================
// Core Enums and Status Types
// =============================================================================

/**
 * Severity level for violations
 * - error: Blocking violation that fails the build
 * - warning: Non-blocking issue that should be addressed
 * - info: Informational message for awareness
 */
export type Severity = 'error' | 'warning' | 'info';

/**
 * Overall status of a validation run
 * - pass: No errors or warnings
 * - fail: At least one error found
 * - warn: No errors, but warnings present
 */
export type Status = 'pass' | 'fail' | 'warn';

/**
 * Exit codes for validator processes
 * - 0: Pass (no issues)
 * - 1: Fail (errors found)
 * - 2: Warn (warnings only, no errors)
 */
export type ExitCode = 0 | 1 | 2;

// =============================================================================
// Violation Types
// =============================================================================

/**
 * Represents a single violation detected by a validator
 */
export interface Violation {
  /** Relative file path where violation was found */
  file: string;
  /** Line number (1-indexed), if applicable */
  line?: number;
  /** Column number (1-indexed), if applicable */
  column?: number;
  /** Rule ID that was violated (e.g., 'ui/no-tauri-invoke') */
  rule: string;
  /** Human-readable description of the violation */
  message: string;
  /** Severity level of the violation */
  severity: Severity;
  /** Optional suggestion for fixing the violation */
  suggestion?: string;
  /** Code snippet showing the violation context */
  snippet?: string;
  /** Additional metadata specific to the violation */
  metadata?: Record<string, unknown>;
}

// =============================================================================
// Report Types
// =============================================================================

/**
 * Complete validation report generated by a validator
 */
export interface ValidationReport {
  /** Name of the validator that generated this report */
  validator: string;
  /** ISO timestamp when validation was run */
  timestamp: string;
  /** Overall status of the validation */
  status: Status;
  /** Count of error-level violations */
  errorCount: number;
  /** Count of warning-level violations */
  warningCount: number;
  /** Count of info-level violations */
  infoCount: number;
  /** List of all violations found */
  violations: Violation[];
  /** Execution time in milliseconds */
  executionTimeMs: number;
  /** Additional metadata about the validation run */
  metadata?: Record<string, unknown>;
}

/**
 * Result returned by a validator function
 */
export interface ValidatorResult {
  /** The complete validation report */
  report: ValidationReport;
  /** Exit code to use when running as CLI */
  exitCode: ExitCode;
}

// =============================================================================
// Configuration Types
// =============================================================================

/**
 * Configuration for a single validation rule
 */
export interface Rule {
  /** Unique identifier for the rule (e.g., 'ui/no-tauri-invoke') */
  id: string;
  /** Human-readable description of what the rule checks */
  description: string;
  /** Severity level when rule is violated */
  severity: Severity;
  /** Whether the rule is enabled */
  enabled: boolean;
}

/**
 * Configuration for a validator
 */
export interface ValidatorConfig {
  /** Unique name of the validator */
  name: string;
  /** Human-readable description of the validator's purpose */
  description: string;
  /** Rules enforced by this validator */
  rules: Rule[];
  /** Glob patterns for files to include */
  includes: string[];
  /** Glob patterns for files to exclude */
  excludes: string[];
}

// =============================================================================
// Import Analysis Types
// =============================================================================

/**
 * Information about a parsed import statement
 */
export interface ImportInfo {
  /** The import source/specifier (e.g., '@openflow/hooks', './utils') */
  source: string;
  /** Named imports from the module */
  specifiers: string[];
  /** Line number where import appears (1-indexed) */
  line: number;
  /** Column number where import starts (1-indexed) */
  column: number;
  /** Whether this is a type-only import */
  isTypeOnly: boolean;
  /** Whether this is a default import */
  isDefault: boolean;
  /** Whether this is a namespace import (import * as) */
  isNamespace: boolean;
  /** The full import statement text */
  text: string;
}

/**
 * Information about an exported symbol
 */
export interface ExportInfo {
  /** Name of the exported symbol */
  name: string;
  /** Whether this is a type export */
  isType: boolean;
  /** Whether this is a default export */
  isDefault: boolean;
  /** Whether this is a re-export */
  isReExport: boolean;
  /** Line number where export appears */
  line: number;
}

// =============================================================================
// Dependency Graph Types
// =============================================================================

/**
 * Package layer classification for architecture boundaries
 */
export type PackageLayer =
  | 'routes' // Level 5: src/routes/
  | 'ui' // Level 4: packages/ui/
  | 'hooks' // Level 3: packages/hooks/
  | 'queries' // Level 2: packages/queries/
  | 'validation' // Level 1: packages/validation/
  | 'generated' // Level 0: packages/generated/
  | 'utils'; // Level 0: packages/utils/

/**
 * Represents a node in the dependency graph
 */
export interface DependencyNode {
  /** Package or module name */
  name: string;
  /** Absolute path to the file/package */
  path: string;
  /** Layer classification */
  layer: PackageLayer;
  /** Set of direct dependencies */
  dependencies: Set<string>;
  /** Set of files/modules that import this one */
  dependents: Set<string>;
}

/**
 * Complete dependency graph for analysis
 */
export interface DependencyGraph {
  /** Map of module path to dependency node */
  nodes: Map<string, DependencyNode>;
  /** Detected circular dependencies (each array is a cycle path) */
  cycles: string[][];
}

// =============================================================================
// Architecture Validation Types
// =============================================================================

/**
 * Violation codes for architecture validation
 */
export type ArchitectureViolationCode =
  | 'FORBIDDEN_IMPORT'
  | 'LAYER_BOUNDARY_VIOLATION'
  | 'CIRCULAR_DEPENDENCY'
  | 'CROSS_PACKAGE_IMPORT';

/**
 * Architecture-specific violation with layer information
 */
export interface ArchitectureViolation extends Violation {
  /** Code identifying the type of architecture violation */
  code: ArchitectureViolationCode;
  /** The problematic import specifier */
  importSpecifier: string;
  /** Layer of the importing file */
  sourceLayer: PackageLayer;
  /** Layer of the imported module (if applicable) */
  targetLayer?: PackageLayer;
}

// =============================================================================
// UI Stateless Validation Types
// =============================================================================

/**
 * Violation codes for UI stateless validation
 */
export type UIStatelessViolationCode =
  | 'UI_NO_TAURI_INVOKE'
  | 'UI_NO_TANSTACK_QUERY'
  | 'UI_NO_HOOKS_PACKAGE'
  | 'UI_NO_QUERIES_PACKAGE';

// =============================================================================
// Query Validation Types
// =============================================================================

/**
 * Violation codes for query layer validation
 */
export type QueryViolationCode =
  | 'QUERY_MUST_USE_INVOKE'
  | 'QUERY_NO_REACT_HOOKS'
  | 'QUERY_MUST_RETURN_PROMISE';

// =============================================================================
// Hook Validation Types
// =============================================================================

/**
 * Violation codes for hook layer validation
 */
export type HookViolationCode = 'HOOK_NO_DIRECT_INVOKE' | 'HOOK_MUST_USE_QUERIES';

// =============================================================================
// Zod Coverage Types
// =============================================================================

/**
 * Violation codes for Zod schema coverage validation
 */
export type ZodCoverageViolationCode =
  | 'ZOD_MISSING_INPUT_SCHEMA'
  | 'ZOD_MISSING_OUTPUT_SCHEMA'
  | 'ZOD_UNUSED_SCHEMA';

/**
 * Information about schema coverage
 */
export interface SchemaCoverage {
  /** Type name */
  typeName: string;
  /** Whether an input schema exists */
  hasInputSchema: boolean;
  /** Whether an output schema exists */
  hasOutputSchema: boolean;
  /** File where the type is used */
  usageFile?: string;
  /** Line where the type is used */
  usageLine?: number;
}

// =============================================================================
// Circular Dependency Types
// =============================================================================

/**
 * Violation codes for circular dependency validation
 */
export type CircularDependencyViolationCode = 'CIRCULAR_PACKAGE_LEVEL' | 'CIRCULAR_MODULE_LEVEL';

/**
 * Information about a detected cycle
 */
export interface CycleInfo {
  /** Ordered list of modules/packages in the cycle */
  path: string[];
  /** Whether this is a package-level or module-level cycle */
  level: 'package' | 'module';
}

// =============================================================================
// Dead Code Types
// =============================================================================

/**
 * Violation codes for dead code validation
 */
export type DeadCodeViolationCode =
  | 'DEAD_UNUSED_EXPORT'
  | 'DEAD_UNUSED_DEPENDENCY'
  | 'DEAD_ORPHAN_FILE';

/**
 * Information about an unused export
 */
export interface UnusedExport {
  /** Name of the unused export */
  name: string;
  /** File where the export is defined */
  file: string;
  /** Line number of the export */
  line: number;
  /** Whether it's a type export */
  isType: boolean;
}

/**
 * Information about an unused dependency
 */
export interface UnusedDependency {
  /** Dependency package name */
  name: string;
  /** Path to the package.json where it's declared */
  packageJsonPath: string;
  /** Whether it's a dev dependency */
  isDevDependency: boolean;
}

// =============================================================================
// Type Staleness Types
// =============================================================================

/**
 * Violation codes for type staleness validation
 */
export type TypeStalenessViolationCode = 'TYPES_STALE_GENERATION' | 'TYPES_MANUAL_EDITS';

// =============================================================================
// Storybook Coverage Types
// =============================================================================

/**
 * Violation codes for Storybook coverage validation
 */
export type StorybookViolationCode = 'STORYBOOK_MISSING_STORY' | 'STORYBOOK_ORPHAN_STORY';

/**
 * Information about Storybook coverage
 */
export interface StorybookCoverage {
  /** Total number of components */
  totalComponents: number;
  /** Number of components with stories */
  componentsWithStories: number;
  /** Coverage percentage */
  coveragePercent: number;
  /** List of components without stories */
  missingStories: string[];
  /** List of orphan story files */
  orphanStories: string[];
}

// =============================================================================
// Route Validation Types
// =============================================================================

/**
 * Violation codes for route validation
 */
export type RouteViolationCode =
  | 'ROUTE_NO_QUERIES_IMPORT'
  | 'ROUTE_NO_DIRECT_INVOKE'
  | 'ROUTE_MAX_LINES';

// =============================================================================
// Test Coverage Types
// =============================================================================

/**
 * Violation codes for test coverage validation
 */
export type TestCoverageViolationCode = 'COVERAGE_BELOW_THRESHOLD';

/**
 * Test coverage threshold configuration
 */
export interface CoverageThreshold {
  /** Package or path */
  path: string;
  /** Minimum coverage percentage required */
  minCoverage: number;
  /** Actual coverage percentage */
  actualCoverage?: number;
}

// =============================================================================
// Tauri Command Types
// =============================================================================

/**
 * Violation codes for Tauri command validation
 */
export type TauriCommandViolationCode =
  | 'TAURI_UNREGISTERED_COMMAND'
  | 'TAURI_ORPHAN_REGISTRATION'
  | 'TAURI_NAMING_CONVENTION';

/**
 * Information about a Tauri command
 */
export interface TauriCommand {
  /** Function name */
  name: string;
  /** File where the command is defined */
  file: string;
  /** Line number of the command */
  line: number;
  /** Whether it's registered in invoke_handler */
  isRegistered: boolean;
}

// =============================================================================
// Rust Service Types
// =============================================================================

/**
 * Violation codes for Rust service layer validation
 */
export type RustServiceViolationCode =
  | 'RUST_BUSINESS_IN_COMMAND'
  | 'RUST_SERVICE_NOT_RESULT'
  | 'RUST_COMMAND_COMPLEXITY';

// =============================================================================
// Aggregated Report Types
// =============================================================================

/**
 * Summary of a single validator's results
 */
export interface ValidatorSummary {
  /** Validator name */
  name: string;
  /** Overall status */
  status: Status;
  /** Error count */
  errors: number;
  /** Warning count */
  warnings: number;
  /** Info count */
  infos: number;
  /** Execution time in ms */
  executionTimeMs: number;
}

/**
 * Aggregated report from running all validators
 */
export interface AggregatedReport {
  /** ISO timestamp when validation suite was run */
  timestamp: string;
  /** Overall status (worst of all validators) */
  status: Status;
  /** Total error count across all validators */
  totalErrors: number;
  /** Total warning count across all validators */
  totalWarnings: number;
  /** Total info count across all validators */
  totalInfos: number;
  /** Summary of each validator's results */
  validators: ValidatorSummary[];
  /** Individual reports from each validator */
  reports: ValidationReport[];
  /** Total execution time in ms */
  totalExecutionTimeMs: number;
}

// =============================================================================
// Reporter Options
// =============================================================================

/**
 * Options for the Reporter class
 */
export interface ReporterOptions {
  /** Output JSON report instead of console */
  json?: boolean;
  /** Enable verbose output */
  verbose?: boolean;
  /** Directory for JSON reports */
  reportDir?: string;
}

// =============================================================================
// File Scanner Types
// =============================================================================

/**
 * Options for file scanning
 */
export interface FileScannerOptions {
  /** Additional patterns to exclude */
  excludes?: string[];
  /** File extensions to include */
  extensions?: string[];
  /** Base directory for scanning */
  cwd?: string;
}

/**
 * Result of a file scan
 */
export interface FileScanResult {
  /** List of matching files (relative paths) */
  files: string[];
  /** Total files scanned before filtering */
  totalScanned: number;
  /** Time taken to scan in ms */
  scanTimeMs: number;
}

// =============================================================================
// Utility Types
// =============================================================================

/**
 * Helper type for creating violation-specific types
 */
export type ViolationWithCode<T extends string> = Violation & {
  code: T;
};

/**
 * Helper type for nullable values
 */
export type Nullable<T> = T | null;

/**
 * Helper type for async validator functions
 */
export type AsyncValidator = (options?: ValidatorOptions) => Promise<ValidatorResult>;

/**
 * Common validator options
 */
export interface ValidatorOptions {
  /** Specific files to validate (overrides includes) */
  files?: string[];
  /** Generate JSON report */
  report?: boolean;
  /** Verbose output */
  verbose?: boolean;
  /** Fix violations automatically (if supported) */
  fix?: boolean;
}
