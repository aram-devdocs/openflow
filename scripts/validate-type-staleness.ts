/**
 * Type Staleness Validator (FR-8)
 *
 * Ensures generated TypeScript types are fresh and haven't been manually edited.
 * Compares generated types against Rust source files using typeshare.
 *
 * Rules:
 * - types/stale-generation: Generated types are older than Rust source (error)
 * - types/manual-edits: Generated file has manual modifications (error)
 *
 * Run: pnpm validate:type-staleness
 * Run with report: pnpm validate:type-staleness --report
 * Run verbose: pnpm validate:type-staleness --verbose
 */

import { execSync } from 'node:child_process';
import { existsSync, mkdtempSync, readFileSync, rmSync, statSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join, relative, resolve } from 'node:path';
import { globSync } from 'glob';

import { PACKAGE_PATHS, ROOT_DIR, TYPE_STALENESS_CONFIG } from './lib/config';
import { Reporter, parseValidatorArgs } from './lib/reporter';
import type { Severity, Violation } from './lib/types';

// =============================================================================
// Types
// =============================================================================

interface TypeStalenessRule {
  ruleId: string;
  description: string;
  severity: Severity;
}

interface RustSourceInfo {
  path: string;
  relativePath: string;
  modifiedTime: Date;
  hasTypeshareAttribute: boolean;
}

interface GeneratedTypeInfo {
  path: string;
  relativePath: string;
  modifiedTime: Date | null;
  exists: boolean;
  content: string | null;
}

// =============================================================================
// Rules
// =============================================================================

const _RULES: TypeStalenessRule[] = [
  {
    ruleId: 'types/stale-generation',
    description: 'Generated types are older than Rust source files',
    severity: 'error',
  },
  {
    ruleId: 'types/manual-edits',
    description: 'Generated file appears to have manual modifications',
    severity: 'error',
  },
];

// =============================================================================
// Configuration
// =============================================================================

/**
 * Path to the Rust types directory
 */
const RUST_TYPES_DIR = resolve(ROOT_DIR, 'src-tauri/src/types');

/**
 * Path to the generated TypeScript types file
 */
const GENERATED_TYPES_PATH = resolve(ROOT_DIR, PACKAGE_PATHS.GENERATED, 'types.ts');

/**
 * Expected header comment in generated file (indicates typeshare output)
 */
const _GENERATED_FILE_MARKERS = [
  '// This file was generated by [ts-rs]',
  '// This file was auto-generated by typeshare',
  '// Generated by typeshare',
  '/* This file was generated by',
  'Generated by',
  // Check for auto-generated notice in any form
];

/**
 * Patterns that indicate manual edits (shouldn't appear in generated code)
 */
const MANUAL_EDIT_INDICATORS = [
  /\/\/\s*TODO:/i, // TODO comments
  /\/\/\s*FIXME:/i, // FIXME comments
  /\/\/\s*HACK:/i, // HACK comments
  /\/\/\s*NOTE:/i, // NOTE comments (manual documentation)
  /\/\*\*[\s\S]*?@author[\s\S]*?\*\//i, // JSDoc with author
  /\/\*\*[\s\S]*?@modified[\s\S]*?\*\//i, // JSDoc with modified
  /eslint-disable/, // ESLint disable comments (manual)
  /@ts-ignore/, // TypeScript ignore comments (manual)
  /@ts-expect-error/, // TypeScript expect-error comments (manual)
  /biome-ignore/, // Biome ignore comments
];

// =============================================================================
// Rust Source Analysis
// =============================================================================

/**
 * Check if a Rust file contains #[typeshare] attributes
 */
function hasTypeshareAttribute(content: string): boolean {
  return /#\[typeshare\]/.test(content) || /#\[typeshare\(/.test(content);
}

/**
 * Get all Rust source files that define types for TypeScript generation
 */
function getRustSourceFiles(): RustSourceInfo[] {
  const rustFiles: RustSourceInfo[] = [];

  // Scan the types directory
  const patterns = ['**/*.rs'];
  const files = globSync(patterns, {
    cwd: RUST_TYPES_DIR,
    absolute: false,
  });

  for (const file of files) {
    const fullPath = resolve(RUST_TYPES_DIR, file);
    const content = readFileSync(fullPath, 'utf-8');
    const stats = statSync(fullPath);

    rustFiles.push({
      path: fullPath,
      relativePath: relative(ROOT_DIR, fullPath),
      modifiedTime: stats.mtime,
      hasTypeshareAttribute: hasTypeshareAttribute(content),
    });
  }

  return rustFiles;
}

/**
 * Get the most recent modification time among Rust source files with typeshare
 */
function getLatestRustModTime(rustFiles: RustSourceInfo[]): {
  latestTime: Date | null;
  latestFile: RustSourceInfo | null;
} {
  let latestTime: Date | null = null;
  let latestFile: RustSourceInfo | null = null;

  for (const file of rustFiles) {
    if (file.hasTypeshareAttribute) {
      if (!latestTime || file.modifiedTime > latestTime) {
        latestTime = file.modifiedTime;
        latestFile = file;
      }
    }
  }

  return { latestTime, latestFile };
}

// =============================================================================
// Generated File Analysis
// =============================================================================

/**
 * Get information about the generated TypeScript file
 */
function getGeneratedTypeInfo(): GeneratedTypeInfo {
  const exists = existsSync(GENERATED_TYPES_PATH);

  if (!exists) {
    return {
      path: GENERATED_TYPES_PATH,
      relativePath: relative(ROOT_DIR, GENERATED_TYPES_PATH),
      modifiedTime: null,
      exists: false,
      content: null,
    };
  }

  const stats = statSync(GENERATED_TYPES_PATH);
  const content = readFileSync(GENERATED_TYPES_PATH, 'utf-8');

  return {
    path: GENERATED_TYPES_PATH,
    relativePath: relative(ROOT_DIR, GENERATED_TYPES_PATH),
    modifiedTime: stats.mtime,
    exists: true,
    content,
  };
}

/**
 * Check if the generated file appears to have manual edits
 */
function detectManualEdits(content: string): {
  hasManualEdits: boolean;
  indicators: string[];
} {
  const indicators: string[] = [];

  for (const pattern of MANUAL_EDIT_INDICATORS) {
    const match = content.match(pattern);
    if (match) {
      indicators.push(match[0]);
    }
  }

  return {
    hasManualEdits: indicators.length > 0,
    indicators,
  };
}

// =============================================================================
// Content Comparison
// =============================================================================

/**
 * Run typeshare to generate fresh types to a temporary file
 * Returns null if typeshare is not available or fails
 */
function generateFreshTypes(verbose: boolean): string | null {
  const tempDir = mkdtempSync(join(tmpdir(), 'typeshare-'));
  const tempFile = join(tempDir, 'types.ts');

  try {
    // Check if typeshare is available
    try {
      execSync('which typeshare', { encoding: 'utf-8', stdio: 'pipe' });
    } catch {
      if (verbose) {
        console.log('  typeshare CLI not found - skipping content comparison');
      }
      return null;
    }

    // Run typeshare to generate fresh types
    const cmd = `typeshare ${RUST_TYPES_DIR} --lang=typescript --output-file=${tempFile}`;
    if (verbose) {
      console.log(`  Running: ${cmd}`);
    }

    execSync(cmd, {
      encoding: 'utf-8',
      stdio: verbose ? 'inherit' : 'pipe',
      cwd: ROOT_DIR,
    });

    if (existsSync(tempFile)) {
      const content = readFileSync(tempFile, 'utf-8');
      return content;
    }

    return null;
  } catch (error) {
    if (verbose) {
      console.log(`  typeshare generation failed: ${error}`);
    }
    return null;
  } finally {
    // Cleanup temp directory
    try {
      rmSync(tempDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Normalize generated content for comparison
 * (removes timestamps, whitespace differences, etc.)
 */
function normalizeContent(content: string): string {
  return (
    content
      // Remove any generated timestamp comments
      .replace(/\/\/\s*Generated at:.*$/gm, '')
      .replace(/\/\/\s*Last updated:.*$/gm, '')
      // Normalize line endings
      .replace(/\r\n/g, '\n')
      // Remove trailing whitespace
      .replace(/[ \t]+$/gm, '')
      // Normalize multiple blank lines
      .replace(/\n{3,}/g, '\n\n')
      // Trim
      .trim()
  );
}

/**
 * Compare current generated types with freshly generated ones
 */
function compareGeneratedContent(
  currentContent: string,
  freshContent: string
): {
  isDifferent: boolean;
  diffSummary: string;
} {
  const normalizedCurrent = normalizeContent(currentContent);
  const normalizedFresh = normalizeContent(freshContent);

  if (normalizedCurrent === normalizedFresh) {
    return { isDifferent: false, diffSummary: '' };
  }

  // Calculate a simple diff summary
  const currentLines = normalizedCurrent.split('\n');
  const freshLines = normalizedFresh.split('\n');

  const currentSet = new Set(currentLines);
  const freshSet = new Set(freshLines);

  const addedLines = freshLines.filter((line) => !currentSet.has(line)).length;
  const removedLines = currentLines.filter((line) => !freshSet.has(line)).length;

  return {
    isDifferent: true,
    diffSummary: `${addedLines} lines would be added, ${removedLines} lines would be removed`,
  };
}

// =============================================================================
// Validation
// =============================================================================

interface ValidationResult {
  violations: Violation[];
  rustFilesChecked: number;
  rustFilesWithTypeshare: number;
  generatedFileExists: boolean;
  isStale: boolean;
  hasManualEdits: boolean;
  contentMismatch: boolean;
}

function validate(verbose = false): ValidationResult {
  const violations: Violation[] = [];

  // Get Rust source files
  if (verbose) {
    console.log('\n  Phase 1: Scanning Rust source files...');
  }

  const rustFiles = getRustSourceFiles();
  const rustFilesWithTypeshare = rustFiles.filter((f) => f.hasTypeshareAttribute);

  if (verbose) {
    console.log(`    Found ${rustFiles.length} Rust files in types directory`);
    console.log(`    ${rustFilesWithTypeshare.length} files have #[typeshare] attribute\n`);
  }

  // Get generated file info
  if (verbose) {
    console.log('  Phase 2: Checking generated TypeScript file...');
  }

  const generatedInfo = getGeneratedTypeInfo();

  if (!generatedInfo.exists) {
    if (verbose) {
      console.log(`    Generated file not found at: ${generatedInfo.relativePath}`);
    }

    // If there are Rust files with typeshare but no generated file, that's an error
    if (rustFilesWithTypeshare.length > 0) {
      violations.push({
        file: generatedInfo.relativePath,
        line: 1,
        column: 1,
        rule: 'types/stale-generation',
        message:
          'Generated types file does not exist but Rust sources have #[typeshare] attributes',
        severity: 'error',
        suggestion: 'Run `pnpm generate:types` to create the generated types file',
        metadata: {
          rustFilesWithTypeshare: rustFilesWithTypeshare.length,
        },
      });
    }

    return {
      violations,
      rustFilesChecked: rustFiles.length,
      rustFilesWithTypeshare: rustFilesWithTypeshare.length,
      generatedFileExists: false,
      isStale: rustFilesWithTypeshare.length > 0,
      hasManualEdits: false,
      contentMismatch: false,
    };
  }

  if (verbose) {
    console.log(`    Found generated file: ${generatedInfo.relativePath}`);
    console.log(`    Modified: ${generatedInfo.modifiedTime?.toISOString()}\n`);
  }

  // Check for staleness based on timestamps (preliminary check)
  if (verbose) {
    console.log('  Phase 3: Checking timestamps...');
  }

  const { latestTime, latestFile } = getLatestRustModTime(rustFiles);
  let timestampStale = false;

  if (latestTime && generatedInfo.modifiedTime) {
    timestampStale = latestTime > generatedInfo.modifiedTime;

    if (verbose) {
      console.log(`    Latest Rust modification: ${latestTime.toISOString()}`);
      console.log(`    Generated file modified: ${generatedInfo.modifiedTime.toISOString()}`);
      console.log(`    Timestamps indicate stale: ${timestampStale}\n`);
    }
  }

  // Check for manual edits
  if (verbose) {
    console.log('  Phase 4: Checking for manual edits...');
  }

  let hasManualEdits = false;
  if (generatedInfo.content) {
    const editCheck = detectManualEdits(generatedInfo.content);
    hasManualEdits = editCheck.hasManualEdits;

    if (verbose) {
      console.log(`    Manual edit indicators found: ${editCheck.indicators.length}`);
      if (editCheck.indicators.length > 0) {
        console.log(`    Indicators: ${editCheck.indicators.join(', ')}`);
      }
      console.log('');
    }

    if (hasManualEdits) {
      violations.push({
        file: generatedInfo.relativePath,
        line: 1,
        column: 1,
        rule: 'types/manual-edits',
        message: `Generated file contains manual edit indicators: ${editCheck.indicators.slice(0, 3).join(', ')}`,
        severity: 'error',
        suggestion:
          'Remove manual edits from the generated file. If type changes are needed, modify the Rust source instead.',
        metadata: {
          indicators: editCheck.indicators,
        },
      });
    }
  }

  // Compare content with fresh generation (authoritative check when available)
  if (verbose) {
    console.log('  Phase 5: Comparing with fresh generation...');
  }

  let contentMismatch = false;
  let isStale = false;
  const freshTypes = generateFreshTypes(verbose);

  if (freshTypes && generatedInfo.content) {
    // Content comparison is available - this is the authoritative check
    const comparison = compareGeneratedContent(generatedInfo.content, freshTypes);
    contentMismatch = comparison.isDifferent;
    isStale = contentMismatch;

    if (verbose) {
      console.log(`    Content matches fresh generation: ${!contentMismatch}`);
      if (contentMismatch) {
        console.log(`    Difference: ${comparison.diffSummary}`);
      }
      console.log('');
    }

    // Report stale only if content actually differs
    if (contentMismatch) {
      violations.push({
        file: generatedInfo.relativePath,
        line: 1,
        column: 1,
        rule: 'types/stale-generation',
        message: `Generated types content differs from fresh generation (${comparison.diffSummary})`,
        severity: 'error',
        suggestion: 'Run `pnpm generate:types` to regenerate TypeScript types from Rust',
        metadata: {
          diffSummary: comparison.diffSummary,
          timestampStale,
        },
      });
    }
  } else {
    // Fallback to timestamp check when content comparison is unavailable
    if (verbose && !freshTypes) {
      console.log('    typeshare not available - falling back to timestamp check\n');
    }

    isStale = timestampStale;

    if (timestampStale && latestFile) {
      violations.push({
        file: generatedInfo.relativePath,
        line: 1,
        column: 1,
        rule: 'types/stale-generation',
        message: `Generated types are older than Rust source (${latestFile.relativePath})`,
        severity: 'error',
        suggestion: 'Run `pnpm generate:types` to regenerate TypeScript types from Rust',
        metadata: {
          generatedModified: generatedInfo.modifiedTime?.toISOString(),
          latestRustModified: latestTime?.toISOString(),
          latestRustFile: latestFile.relativePath,
          note: 'Timestamp-based check (typeshare unavailable for content comparison)',
        },
      });
    }
  }

  return {
    violations,
    rustFilesChecked: rustFiles.length,
    rustFilesWithTypeshare: rustFilesWithTypeshare.length,
    generatedFileExists: generatedInfo.exists,
    isStale,
    hasManualEdits,
    contentMismatch,
  };
}

// =============================================================================
// Main Entry Point
// =============================================================================

function main(): void {
  const args = parseValidatorArgs();

  if (args.help) {
    console.log(`
Type Staleness Validator

Usage: pnpm validate:type-staleness [options]

Options:
  --report, -r    Generate JSON report in reports/type-staleness.json
  --verbose, -v   Show detailed output including comparison details
  --help, -h      Show this help message

Description:
  Ensures generated TypeScript types match the Rust source definitions.
  Detects stale types (when Rust has changed but types weren't regenerated)
  and manual edits to the generated file.

Rules:
  types/stale-generation  - Generated types are older than Rust source (error)
  types/manual-edits      - Generated file has manual modifications (error)

How it works:
  1. Scans Rust files in src-tauri/src/types/ for #[typeshare] attributes
  2. Compares modification timestamps with packages/generated/types.ts
  3. Checks for manual edit indicators (TODO, FIXME, ts-ignore, etc.)
  4. Optionally runs typeshare to compare content (if typeshare is installed)

Philosophy:
  Generated types are a single source of truth that must stay in sync with
  Rust definitions. Manual edits create drift and maintenance burden.
  If types need to change, modify the Rust source and regenerate.

  This is a blocking validator - stale or edited types will fail CI.

Fix:
  pnpm generate:types    # Regenerate types from Rust sources

Examples:
  pnpm validate:type-staleness              # Run with default output
  pnpm validate:type-staleness --verbose    # Show detailed analysis
  pnpm validate:type-staleness --report     # Generate JSON report
`);
    process.exit(0);
  }

  const reporter = new Reporter('type-staleness', {
    json: false,
    verbose: args.verbose,
    reportDir: 'reports',
  });

  // Print header
  reporter.printHeader();

  // Run validation
  const result = validate(args.verbose);

  // Add violations to reporter
  reporter.addViolations(result.violations);

  // Add metadata
  reporter.setMetadata({
    rustFilesChecked: result.rustFilesChecked,
    rustFilesWithTypeshare: result.rustFilesWithTypeshare,
    generatedFileExists: result.generatedFileExists,
    isStale: result.isStale,
    hasManualEdits: result.hasManualEdits,
    contentMismatch: result.contentMismatch,
    config: TYPE_STALENESS_CONFIG.name,
  });

  // Print summary info
  if (!args.verbose) {
    console.log(`  Rust files checked: ${result.rustFilesChecked}`);
    console.log(`  Files with #[typeshare]: ${result.rustFilesWithTypeshare}`);
    console.log(`  Generated file exists: ${result.generatedFileExists ? 'yes' : 'no'}`);
    if (result.generatedFileExists) {
      console.log(`  Types fresh: ${!result.isStale ? 'yes' : 'no'}`);
      console.log(`  No manual edits: ${!result.hasManualEdits ? 'yes' : 'no'}`);
    }
  }

  // Print summary
  reporter.printSummary();

  // Write JSON report if requested
  if (args.report) {
    reporter.writeReport();
  }

  // Exit with appropriate code
  process.exit(reporter.getExitCode());
}

// Run main
main();
