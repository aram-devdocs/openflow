name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri -> target

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Install typeshare-cli
        run: cargo install typeshare-cli

      - name: Generate types
        run: pnpm generate:types

      - name: Generate routes
        run: pnpm generate:routes

      - name: TypeScript check
        run: pnpm typecheck

      - name: Lint
        run: pnpm lint

      - name: Test
        run: pnpm test

      - name: Create dist directory for Tauri
        run: mkdir -p dist

      - name: Rust check
        working-directory: src-tauri
        run: cargo check

      - name: Rust test
        working-directory: src-tauri
        run: cargo test

      - name: Rust clippy
        working-directory: src-tauri
        run: cargo clippy -- -D warnings

  # Architecture Validation Job
  # Runs all validators and generates JSON reports
  validation:
    name: Architecture Validation
    runs-on: ubuntu-latest
    # Run in parallel with the check job, not after
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Generate types (for type-staleness validation)
        run: pnpm generate:types
        continue-on-error: true

      - name: Generate routes
        run: pnpm generate:routes
        continue-on-error: true

      - name: Create reports directory
        run: mkdir -p reports

      # Run blocking validators (must pass for CI)
      # Exit codes: 0 = pass, 1 = fail, 2 = pass with warnings
      - name: Run blocking validators
        id: blocking
        run: |
          set +e
          pnpm validate:blocking --report
          EXIT_CODE=$?
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          # Exit 0 if pass (0) or warnings (2), exit 1 only for actual failures
          if [ $EXIT_CODE -eq 1 ]; then
            exit 1
          fi
          exit 0

      # Run non-blocking validators (warnings only)
      - name: Run non-blocking validators
        id: non-blocking
        run: |
          set +e
          pnpm validate:all --non-blocking --report
          # Always pass - these are non-blocking
          exit 0

      # Upload validation reports as artifacts
      - name: Upload validation reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: validation-reports
          path: reports/
          retention-days: 30

      # Comment on PR with validation results
      - name: Comment PR with validation results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Read all JSON reports
            const reportsDir = 'reports';
            let reports = [];
            let aggregatedReport = null;

            try {
              const files = fs.readdirSync(reportsDir).filter(f => f.endsWith('.json'));

              for (const file of files) {
                try {
                  const content = fs.readFileSync(path.join(reportsDir, file), 'utf-8');
                  const report = JSON.parse(content);

                  if (file === 'all.json') {
                    aggregatedReport = report;
                  } else {
                    reports.push(report);
                  }
                } catch (e) {
                  console.log(`Failed to parse ${file}: ${e.message}`);
                }
              }
            } catch (e) {
              console.log(`Failed to read reports directory: ${e.message}`);
            }

            // If no reports, exit early
            if (reports.length === 0 && !aggregatedReport) {
              console.log('No validation reports found');
              return;
            }

            // Use aggregated report if available, otherwise build from individual reports
            const data = aggregatedReport || {
              status: reports.some(r => r.status === 'fail') ? 'fail' :
                      reports.some(r => r.status === 'warn') ? 'warn' : 'pass',
              totalErrors: reports.reduce((sum, r) => sum + (r.errorCount || 0), 0),
              totalWarnings: reports.reduce((sum, r) => sum + (r.warningCount || 0), 0),
              validators: reports.map(r => ({
                name: r.validator,
                status: r.status,
                errors: r.errorCount || 0,
                warnings: r.warningCount || 0
              }))
            };

            // Build summary table
            const statusIcon = (status) => {
              if (status === 'pass') return ':white_check_mark:';
              if (status === 'warn') return ':warning:';
              return ':x:';
            };

            const validators = data.validators || reports.map(r => ({
              name: r.validator,
              status: r.status,
              errors: r.errorCount || 0,
              warnings: r.warningCount || 0
            }));

            const summaryRows = validators.map(v =>
              `| ${statusIcon(v.status)} | ${v.name} | ${v.errors} | ${v.warnings} |`
            ).join('\n');

            // Overall status
            const overallIcon = statusIcon(data.status);
            const overallStatus = data.status === 'pass' ? 'All checks passed' :
                                  data.status === 'warn' ? 'Passed with warnings' : 'Validation failed';

            // Build violations summary for failures
            let violationsSummary = '';
            if (data.status === 'fail' || data.totalErrors > 0) {
              const failedValidators = validators.filter(v => v.errors > 0);
              if (failedValidators.length > 0) {
                violationsSummary = `\n\n### :rotating_light: Blocking Violations\n\n`;
                violationsSummary += `The following validators reported errors that must be fixed:\n\n`;
                for (const v of failedValidators) {
                  violationsSummary += `- **${v.name}**: ${v.errors} error${v.errors !== 1 ? 's' : ''}\n`;
                }
              }
            }

            // Build the comment body
            const bodyLines = [
              `## ${overallIcon} Validation Results`,
              '',
              overallStatus,
              '',
              '| Status | Validator | Errors | Warnings |',
              '|--------|-----------|--------|----------|',
              summaryRows,
              '',
              `**Total:** ${data.totalErrors || 0} error${data.totalErrors !== 1 ? 's' : ''}, ${data.totalWarnings || 0} warning${data.totalWarnings !== 1 ? 's' : ''}`,
              violationsSummary,
              '<details>',
              '<summary>View full report</summary>',
              '',
              '```json',
              // Truncate the JSON to avoid GitHub's 65536 character limit
              (() => {
                const fullJson = JSON.stringify(data, null, 2);
                const maxLen = 50000; // Leave room for the rest of the comment
                if (fullJson.length > maxLen) {
                  return fullJson.substring(0, maxLen) + '\n... (truncated, see artifacts for full report)';
                }
                return fullJson;
              })(),
              '```',
              '',
              '</details>',
              '',
              '---',
              '*Generated by [OpenFlow Validation Suite](https://github.com/openflow)*'
            ];
            const body = bodyLines.join('\n');

            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Validation Results')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      # Fail the job if blocking validators had actual failures (exit code 1)
      # Note: Exit code 2 means warnings which is acceptable
      - name: Check blocking validators status
        if: failure() && steps.blocking.outcome == 'failure'
        run: |
          echo "::error::Blocking validators failed. Please fix the architecture violations."
          echo "Exit code was: ${{ steps.blocking.outputs.exit_code }}"
          exit 1
