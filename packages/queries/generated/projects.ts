// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
//
// Generated by: scripts/generate-queries.ts
// Source: crates/openflow-contracts/src/endpoints/mod.rs
// Domain: projects
// Generated at: 2026-01-02T16:30:55.301Z
//
// This file contains type-safe query functions for the projects domain.
// Each function wraps a Tauri IPC command with validation and logging.
//
// To regenerate: pnpm generate:queries
//
// @see CLAUDE.md - Query Layer Patterns section
// =============================================================================

import type { CreateProjectRequest, Project, UpdateProjectRequest } from '@openflow/generated';
import { createProjectRequestSchema, updateProjectRequestSchema } from '@openflow/validation';
import { createLogger } from '@openflow/utils';
import { invoke } from '../utils.js';

const logger = createLogger('queries:projects:generated');

/**
 * Archive a project (soft delete)
 *
 * @endpoint POST /api/projects/:id/archive
 * @command archive_project
 * @param id - Path parameter: id
 * @returns Promise resolving to Project
 * @throws Error if validation or query fails
 */
export async function archiveProject(id: string): Promise<Project> {
  logger.debug('Calling archive_project', { id });

  try {
    const result = await invoke<Project>('archive_project', { id: id });

    logger.info('archive_project completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('archive_project failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Create a new project
 *
 * @endpoint POST /api/projects
 * @command create_project
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Project
 * @throws Error if validation or query fails
 */
export async function createProject(request: CreateProjectRequest): Promise<Project> {
  logger.debug('Calling create_project');

  try {
    const validated = createProjectRequestSchema.parse(request);
    const result = await invoke<Project>('create_project', { request: validated });

    logger.info('create_project completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('create_project failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Delete a project permanently
 *
 * @endpoint DELETE /api/projects/:id
 * @command delete_project
 * @param id - Path parameter: id
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function deleteProject(id: string): Promise<void> {
  logger.debug('Calling delete_project', { id });

  try {
    await invoke<void>('delete_project', { id: id });

    logger.info('delete_project completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('delete_project failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get a project by ID
 *
 * @endpoint GET /api/projects/:id
 * @command get_project
 * @param id - Path parameter: id
 * @returns Promise resolving to Project
 * @throws Error if validation or query fails
 */
export async function getProject(id: string): Promise<Project> {
  logger.debug('Calling get_project', { id });

  try {
    const result = await invoke<Project>('get_project', { id: id });

    logger.info('get_project completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_project failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List all archived projects
 *
 * @endpoint GET /api/projects/archived
 * @command list_archived_projects
 * @returns Promise resolving to Project[]
 * @throws Error if validation or query fails
 */
export async function listArchivedProjects(): Promise<Project[]> {
  logger.debug('Calling list_archived_projects');

  try {
    const result = await invoke<Project[]>('list_archived_projects');

    logger.info('list_archived_projects completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_archived_projects failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List all active projects
 *
 * @endpoint GET /api/projects
 * @command list_projects
 * @returns Promise resolving to Project[]
 * @throws Error if validation or query fails
 */
export async function listProjects(): Promise<Project[]> {
  logger.debug('Calling list_projects');

  try {
    const result = await invoke<Project[]>('list_projects');

    logger.info('list_projects completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_projects failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Unarchive a project
 *
 * @endpoint POST /api/projects/:id/unarchive
 * @command unarchive_project
 * @param id - Path parameter: id
 * @returns Promise resolving to Project
 * @throws Error if validation or query fails
 */
export async function unarchiveProject(id: string): Promise<Project> {
  logger.debug('Calling unarchive_project', { id });

  try {
    const result = await invoke<Project>('unarchive_project', { id: id });

    logger.info('unarchive_project completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('unarchive_project failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Update an existing project
 *
 * @endpoint PATCH /api/projects/:id
 * @command update_project
 * @param id - Path parameter: id
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Project
 * @throws Error if validation or query fails
 */
export async function updateProject(id: string, request: UpdateProjectRequest): Promise<Project> {
  logger.debug('Calling update_project', { id });

  try {
    const validated = updateProjectRequestSchema.parse(request);
    const result = await invoke<Project>('update_project', { id: id, request: validated });

    logger.info('update_project completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('update_project failed', { error: errorMessage });
    throw error;
  }
}
