// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
//
// Generated by: scripts/generate-queries.ts
// Source: crates/openflow-contracts/src/endpoints/mod.rs
// Domain: tasks
// Generated at: 2026-01-02T23:48:54.961Z
//
// This file contains type-safe query functions for the tasks domain.
// Each function wraps a Tauri IPC command with validation and logging.
//
// To regenerate: pnpm generate:queries
//
// @see CLAUDE.md - Query Layer Patterns section
// =============================================================================

import type {
  CreateTaskRequest,
  Task,
  TaskWithChats,
  UpdateTaskRequest,
} from '@openflow/generated';
import { createLogger } from '@openflow/utils';
import { createTaskRequestSchema, updateTaskRequestSchema } from '@openflow/validation';
import { invoke } from '../utils.js';

const logger = createLogger('queries:tasks:generated');

/**
 * Archive a task (soft delete)
 *
 * @endpoint POST /api/tasks/:id/archive
 * @command archive_task
 * @param id - Path parameter: id
 * @returns Promise resolving to Task
 * @throws Error if validation or query fails
 */
export async function archiveTask(id: string): Promise<Task> {
  logger.debug('Calling archive_task', { id });

  try {
    const result = await invoke<Task>('archive_task', { id: id });

    logger.info('archive_task completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('archive_task failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Create a new task
 *
 * @endpoint POST /api/tasks
 * @command create_task
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Task
 * @throws Error if validation or query fails
 */
export async function createTask(request: CreateTaskRequest): Promise<Task> {
  logger.debug('Calling create_task');

  try {
    const validated = createTaskRequestSchema.parse(request);
    const result = await invoke<Task>('create_task', { request: validated });

    logger.info('create_task completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('create_task failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Delete a task permanently
 *
 * @endpoint DELETE /api/tasks/:id
 * @command delete_task
 * @param id - Path parameter: id
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function deleteTask(id: string): Promise<void> {
  logger.debug('Calling delete_task', { id });

  try {
    await invoke<void>('delete_task', { id: id });

    logger.info('delete_task completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('delete_task failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Duplicate a task
 *
 * @endpoint POST /api/tasks/:id/duplicate
 * @command duplicate_task
 * @param id - Path parameter: id
 * @returns Promise resolving to Task
 * @throws Error if validation or query fails
 */
export async function duplicateTask(id: string): Promise<Task> {
  logger.debug('Calling duplicate_task', { id });

  try {
    const result = await invoke<Task>('duplicate_task', { id: id });

    logger.info('duplicate_task completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('duplicate_task failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get a task by ID with its chats
 *
 * @endpoint GET /api/tasks/:id
 * @command get_task
 * @param id - Path parameter: id
 * @returns Promise resolving to TaskWithChats
 * @throws Error if validation or query fails
 */
export async function getTask(id: string): Promise<TaskWithChats> {
  logger.debug('Calling get_task', { id });

  try {
    const result = await invoke<TaskWithChats>('get_task', { id: id });

    logger.info('get_task completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_task failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List tasks, optionally filtered by project
 *
 * @endpoint GET /api/tasks
 * @command list_tasks
 * @param projectId - Query parameter: projectId (optional)
 * @param includeArchived - Query parameter: includeArchived (optional)
 * @returns Promise resolving to Task[]
 * @throws Error if validation or query fails
 */
export async function listTasks(projectId?: string, includeArchived?: string): Promise<Task[]> {
  logger.debug('Calling list_tasks');

  try {
    const result = await invoke<Task[]>('list_tasks', {
      projectId: projectId,
      includeArchived: includeArchived,
    });

    logger.info('list_tasks completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_tasks failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Unarchive a task
 *
 * @endpoint POST /api/tasks/:id/unarchive
 * @command unarchive_task
 * @param id - Path parameter: id
 * @returns Promise resolving to Task
 * @throws Error if validation or query fails
 */
export async function unarchiveTask(id: string): Promise<Task> {
  logger.debug('Calling unarchive_task', { id });

  try {
    const result = await invoke<Task>('unarchive_task', { id: id });

    logger.info('unarchive_task completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('unarchive_task failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Update an existing task
 *
 * @endpoint PATCH /api/tasks/:id
 * @command update_task
 * @param id - Path parameter: id
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Task
 * @throws Error if validation or query fails
 */
export async function updateTask(id: string, request: UpdateTaskRequest): Promise<Task> {
  logger.debug('Calling update_task', { id });

  try {
    const validated = updateTaskRequestSchema.parse(request);
    const result = await invoke<Task>('update_task', { id: id, request: validated });

    logger.info('update_task completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('update_task failed', { error: errorMessage });
    throw error;
  }
}
