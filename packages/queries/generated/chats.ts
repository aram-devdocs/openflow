// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
//
// Generated by: scripts/generate-queries.ts
// Source: crates/openflow-contracts/src/endpoints/mod.rs
// Domain: chats
// Generated at: 2026-01-02T06:27:35.447Z
//
// This file contains type-safe query functions for the chats domain.
// Each function wraps a Tauri IPC command with validation and logging.
//
// To regenerate: pnpm generate:queries
//
// @see CLAUDE.md - Query Layer Patterns section
// =============================================================================

import type {
  Chat,
  ChatWithMessages,
  CreateChatRequest,
  UpdateChatRequest,
} from '@openflow/generated';
import { createLogger } from '@openflow/utils';
import { createChatRequestSchema, updateChatRequestSchema } from '@openflow/validation';
import { invoke } from '../utils.js';

const logger = createLogger('queries:chats:generated');

/**
 * Archive a chat (soft delete)
 *
 * @endpoint POST /api/chats/:id/archive
 * @command archive_chat
 * @param id - Path parameter: id
 * @returns Promise resolving to Chat
 * @throws Error if validation or query fails
 */
export async function archiveChat(id: string): Promise<Chat> {
  logger.debug('Calling archive_chat', { id });

  try {
    const result = await invoke<Chat>('archive_chat', { id: id });

    logger.info('archive_chat completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('archive_chat failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Create a new chat
 *
 * @endpoint POST /api/chats
 * @command create_chat
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Chat
 * @throws Error if validation or query fails
 */
export async function createChat(request: CreateChatRequest): Promise<Chat> {
  logger.debug('Calling create_chat');

  try {
    const validated = createChatRequestSchema.parse(request);
    const result = await invoke<Chat>('create_chat', { request: validated });

    logger.info('create_chat completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('create_chat failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Delete a chat permanently
 *
 * @endpoint DELETE /api/chats/:id
 * @command delete_chat
 * @param id - Path parameter: id
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function deleteChat(id: string): Promise<void> {
  logger.debug('Calling delete_chat', { id });

  try {
    await invoke<void>('delete_chat', { id: id });

    logger.info('delete_chat completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('delete_chat failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get a chat by ID with its messages
 *
 * @endpoint GET /api/chats/:id
 * @command get_chat
 * @param id - Path parameter: id
 * @returns Promise resolving to ChatWithMessages
 * @throws Error if validation or query fails
 */
export async function getChat(id: string): Promise<ChatWithMessages> {
  logger.debug('Calling get_chat', { id });

  try {
    const result = await invoke<ChatWithMessages>('get_chat', { id: id });

    logger.info('get_chat completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_chat failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List all archived chats
 *
 * @endpoint GET /api/chats/archived
 * @command list_archived_chats
 * @returns Promise resolving to Chat[]
 * @throws Error if validation or query fails
 */
export async function listArchivedChats(): Promise<Chat[]> {
  logger.debug('Calling list_archived_chats');

  try {
    const result = await invoke<Chat[]>('list_archived_chats');

    logger.info('list_archived_chats completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_archived_chats failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List chats for a task
 *
 * @endpoint GET /api/chats
 * @command list_chats
 * @param taskId - Query parameter: task_id (optional)
 * @returns Promise resolving to Chat[]
 * @throws Error if validation or query fails
 */
export async function listChats(taskId?: string): Promise<Chat[]> {
  logger.debug('Calling list_chats');

  try {
    const result = await invoke<Chat[]>('list_chats', { task_id: taskId });

    logger.info('list_chats completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_chats failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List all chats in a project
 *
 * @endpoint GET /api/projects/:project_id/chats
 * @command list_chats_by_project
 * @param projectId - Path parameter: project_id
 * @returns Promise resolving to Chat[]
 * @throws Error if validation or query fails
 */
export async function listChatsByProject(projectId: string): Promise<Chat[]> {
  logger.debug('Calling list_chats_by_project', { projectId });

  try {
    const result = await invoke<Chat[]>('list_chats_by_project', { project_id: projectId });

    logger.info('list_chats_by_project completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_chats_by_project failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List standalone chats (not attached to tasks)
 *
 * @endpoint GET /api/chats/standalone
 * @command list_standalone_chats
 * @param projectId - Query parameter: project_id (optional)
 * @returns Promise resolving to Chat[]
 * @throws Error if validation or query fails
 */
export async function listStandaloneChats(projectId?: string): Promise<Chat[]> {
  logger.debug('Calling list_standalone_chats');

  try {
    const result = await invoke<Chat[]>('list_standalone_chats', { project_id: projectId });

    logger.info('list_standalone_chats completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_standalone_chats failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Start a workflow step by creating its worktree
 *
 * @endpoint POST /api/chats/:id/start-step
 * @command start_workflow_step
 * @param id - Path parameter: id
 * @returns Promise resolving to Chat
 * @throws Error if validation or query fails
 */
export async function startWorkflowStep(id: string): Promise<Chat> {
  logger.debug('Calling start_workflow_step', { id });

  try {
    const result = await invoke<Chat>('start_workflow_step', { id: id });

    logger.info('start_workflow_step completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('start_workflow_step failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Toggle completion status of a workflow step chat
 *
 * @endpoint POST /api/chats/:id/toggle-step
 * @command toggle_step_complete
 * @param id - Path parameter: id
 * @returns Promise resolving to Chat
 * @throws Error if validation or query fails
 */
export async function toggleStepComplete(id: string): Promise<Chat> {
  logger.debug('Calling toggle_step_complete', { id });

  try {
    const result = await invoke<Chat>('toggle_step_complete', { id: id });

    logger.info('toggle_step_complete completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('toggle_step_complete failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Unarchive a chat
 *
 * @endpoint POST /api/chats/:id/unarchive
 * @command unarchive_chat
 * @param id - Path parameter: id
 * @returns Promise resolving to Chat
 * @throws Error if validation or query fails
 */
export async function unarchiveChat(id: string): Promise<Chat> {
  logger.debug('Calling unarchive_chat', { id });

  try {
    const result = await invoke<Chat>('unarchive_chat', { id: id });

    logger.info('unarchive_chat completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('unarchive_chat failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Update an existing chat
 *
 * @endpoint PATCH /api/chats/:id
 * @command update_chat
 * @param id - Path parameter: id
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Chat
 * @throws Error if validation or query fails
 */
export async function updateChat(id: string, request: UpdateChatRequest): Promise<Chat> {
  logger.debug('Calling update_chat', { id });

  try {
    const validated = updateChatRequestSchema.parse(request);
    const result = await invoke<Chat>('update_chat', { id: id, request: validated });

    logger.info('update_chat completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('update_chat failed', { error: errorMessage });
    throw error;
  }
}
