// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
//
// Generated by: scripts/generate-queries.ts
// Source: crates/openflow-contracts/src/endpoints/mod.rs
// Domain: git
// Generated at: 2026-01-02T16:30:55.300Z
//
// This file contains type-safe query functions for the git domain.
// Each function wraps a Tauri IPC command with validation and logging.
//
// To regenerate: pnpm generate:queries
//
// @see CLAUDE.md - Query Layer Patterns section
// =============================================================================

import type {
  Commit,
  CreateWorktreeRequest,
  DeleteWorktreeRequest,
  FileDiff,
  PushBranchRequest,
  Worktree,
} from '@openflow/generated';
import { createLogger } from '@openflow/utils';
import {
  createWorktreeRequestSchema,
  deleteWorktreeRequestSchema,
  pushBranchRequestSchema,
} from '@openflow/validation';
import { invoke } from '../utils.js';

const logger = createLogger('queries:git:generated');

/**
 * Create a new git worktree
 *
 * @endpoint POST /api/git/worktrees
 * @command create_worktree
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Worktree
 * @throws Error if validation or query fails
 */
export async function createWorktree(request: CreateWorktreeRequest): Promise<Worktree> {
  logger.debug('Calling create_worktree');

  try {
    const validated = createWorktreeRequestSchema.parse(request);
    const result = await invoke<Worktree>('create_worktree', { request: validated });

    logger.info('create_worktree completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('create_worktree failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Delete a git worktree
 *
 * @endpoint DELETE /api/git/worktrees
 * @command delete_worktree
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function deleteWorktree(request: DeleteWorktreeRequest): Promise<void> {
  logger.debug('Calling delete_worktree');

  try {
    const validated = deleteWorktreeRequestSchema.parse(request);
    await invoke<void>('delete_worktree', { request: validated });

    logger.info('delete_worktree completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('delete_worktree failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get commits for a worktree
 *
 * @endpoint GET /api/git/commits
 * @command get_commits
 * @param worktreePath - Query parameter: worktree_path (optional)
 * @param limit - Query parameter: limit (optional)
 * @param baseRef - Query parameter: base_ref (optional)
 * @returns Promise resolving to Commit[]
 * @throws Error if validation or query fails
 */
export async function getCommits(
  worktreePath?: string,
  limit?: string,
  baseRef?: string
): Promise<Commit[]> {
  logger.debug('Calling get_commits');

  try {
    const result = await invoke<Commit[]>('get_commits', {
      worktree_path: worktreePath,
      limit: limit,
      base_ref: baseRef,
    });

    logger.info('get_commits completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_commits failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get current branch name
 *
 * @endpoint GET /api/git/branch/current
 * @command get_current_branch
 * @param repoPath - Query parameter: repo_path (optional)
 * @returns Promise resolving to string
 * @throws Error if validation or query fails
 */
export async function getCurrentBranch(repoPath?: string): Promise<string> {
  logger.debug('Calling get_current_branch');

  try {
    const result = await invoke<string>('get_current_branch', { repo_path: repoPath });

    logger.info('get_current_branch completed');

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_current_branch failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get git diff for a worktree
 *
 * @endpoint GET /api/git/diff
 * @command get_diff
 * @param worktreePath - Query parameter: worktree_path (optional)
 * @param baseRef - Query parameter: base_ref (optional)
 * @returns Promise resolving to FileDiff[]
 * @throws Error if validation or query fails
 */
export async function getDiff(worktreePath?: string, baseRef?: string): Promise<FileDiff[]> {
  logger.debug('Calling get_diff');

  try {
    const result = await invoke<FileDiff[]>('get_diff', {
      worktree_path: worktreePath,
      base_ref: baseRef,
    });

    logger.info('get_diff completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_diff failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get HEAD commit hash
 *
 * @endpoint GET /api/git/head
 * @command get_head_commit
 * @param repoPath - Query parameter: repo_path (optional)
 * @returns Promise resolving to string
 * @throws Error if validation or query fails
 */
export async function getHeadCommit(repoPath?: string): Promise<string> {
  logger.debug('Calling get_head_commit');

  try {
    const result = await invoke<string>('get_head_commit', { repo_path: repoPath });

    logger.info('get_head_commit completed');

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_head_commit failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get commits for a task's worktree
 *
 * @endpoint GET /api/git/tasks/:task_id/commits
 * @command get_task_commits
 * @param taskId - Path parameter: task_id
 * @param limit - Query parameter: limit (optional)
 * @returns Promise resolving to Commit[]
 * @throws Error if validation or query fails
 */
export async function getTaskCommits(taskId: string, limit?: string): Promise<Commit[]> {
  logger.debug('Calling get_task_commits', { taskId });

  try {
    const result = await invoke<Commit[]>('get_task_commits', { task_id: taskId, limit: limit });

    logger.info('get_task_commits completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_task_commits failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get git diff for a task's worktree
 *
 * @endpoint GET /api/git/tasks/:task_id/diff
 * @command get_task_diff
 * @param taskId - Path parameter: task_id
 * @returns Promise resolving to FileDiff[]
 * @throws Error if validation or query fails
 */
export async function getTaskDiff(taskId: string): Promise<FileDiff[]> {
  logger.debug('Calling get_task_diff', { taskId });

  try {
    const result = await invoke<FileDiff[]>('get_task_diff', { task_id: taskId });

    logger.info('get_task_diff completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_task_diff failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Check if repository has uncommitted changes
 *
 * @endpoint GET /api/git/status/dirty
 * @command has_uncommitted_changes
 * @param repoPath - Query parameter: repo_path (optional)
 * @returns Promise resolving to boolean
 * @throws Error if validation or query fails
 */
export async function hasUncommittedChanges(repoPath?: string): Promise<boolean> {
  logger.debug('Calling has_uncommitted_changes');

  try {
    const result = await invoke<boolean>('has_uncommitted_changes', { repo_path: repoPath });

    logger.info('has_uncommitted_changes completed');

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('has_uncommitted_changes failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List git worktrees for a repository
 *
 * @endpoint GET /api/git/worktrees
 * @command list_worktrees
 * @param repoPath - Query parameter: repo_path (optional)
 * @returns Promise resolving to Worktree[]
 * @throws Error if validation or query fails
 */
export async function listWorktrees(repoPath?: string): Promise<Worktree[]> {
  logger.debug('Calling list_worktrees');

  try {
    const result = await invoke<Worktree[]>('list_worktrees', { repo_path: repoPath });

    logger.info('list_worktrees completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_worktrees failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Push a branch to remote
 *
 * @endpoint POST /api/git/push
 * @command push_branch
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function pushBranch(request: PushBranchRequest): Promise<void> {
  logger.debug('Calling push_branch');

  try {
    const validated = pushBranchRequestSchema.parse(request);
    await invoke<void>('push_branch', { request: validated });

    logger.info('push_branch completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('push_branch failed', { error: errorMessage });
    throw error;
  }
}
