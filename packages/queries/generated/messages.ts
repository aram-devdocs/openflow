// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
//
// Generated by: scripts/generate-queries.ts
// Source: crates/openflow-contracts/src/endpoints/mod.rs
// Domain: messages
// Generated at: 2026-01-02T16:30:55.301Z
//
// This file contains type-safe query functions for the messages domain.
// Each function wraps a Tauri IPC command with validation and logging.
//
// To regenerate: pnpm generate:queries
//
// @see CLAUDE.md - Query Layer Patterns section
// =============================================================================

import type {
  AppendMessageContentRequest,
  CreateMessageRequest,
  Message,
  SetMessageStreamingRequest,
} from '@openflow/generated';
import { createLogger } from '@openflow/utils';
import {
  appendMessageContentRequestSchema,
  createMessageRequestSchema,
  setMessageStreamingRequestSchema,
} from '@openflow/validation';
import { invoke } from '../utils.js';

const logger = createLogger('queries:messages:generated');

/**
 * Append content to a message (for streaming)
 *
 * @endpoint POST /api/messages/:id/append
 * @command append_message_content
 * @param id - Path parameter: id
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Message
 * @throws Error if validation or query fails
 */
export async function appendMessageContent(
  id: string,
  request: AppendMessageContentRequest
): Promise<Message> {
  logger.debug('Calling append_message_content', { id });

  try {
    const validated = appendMessageContentRequestSchema.parse(request);
    const result = await invoke<Message>('append_message_content', { id: id, request: validated });

    logger.info('append_message_content completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('append_message_content failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Create a new message
 *
 * @endpoint POST /api/messages
 * @command create_message
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Message
 * @throws Error if validation or query fails
 */
export async function createMessage(request: CreateMessageRequest): Promise<Message> {
  logger.debug('Calling create_message');

  try {
    const validated = createMessageRequestSchema.parse(request);
    const result = await invoke<Message>('create_message', { request: validated });

    logger.info('create_message completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('create_message failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Delete a message
 *
 * @endpoint DELETE /api/messages/:id
 * @command delete_message
 * @param id - Path parameter: id
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function deleteMessage(id: string): Promise<void> {
  logger.debug('Calling delete_message', { id });

  try {
    await invoke<void>('delete_message', { id: id });

    logger.info('delete_message completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('delete_message failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get a message by ID
 *
 * @endpoint GET /api/messages/:id
 * @command get_message
 * @param id - Path parameter: id
 * @returns Promise resolving to Message
 * @throws Error if validation or query fails
 */
export async function getMessage(id: string): Promise<Message> {
  logger.debug('Calling get_message', { id });

  try {
    const result = await invoke<Message>('get_message', { id: id });

    logger.info('get_message completed', { id: (result as unknown as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_message failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List messages for a chat
 *
 * @endpoint GET /api/messages
 * @command list_messages
 * @param chatId - Query parameter: chat_id (optional)
 * @returns Promise resolving to Message[]
 * @throws Error if validation or query fails
 */
export async function listMessages(chatId?: string): Promise<Message[]> {
  logger.debug('Calling list_messages');

  try {
    const result = await invoke<Message[]>('list_messages', { chat_id: chatId });

    logger.info('list_messages completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_messages failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Set streaming status of a message
 *
 * @endpoint PATCH /api/messages/:id/streaming
 * @command set_message_streaming
 * @param id - Path parameter: id
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to Message
 * @throws Error if validation or query fails
 */
export async function setMessageStreaming(
  id: string,
  request: SetMessageStreamingRequest
): Promise<Message> {
  logger.debug('Calling set_message_streaming', { id });

  try {
    const validated = setMessageStreamingRequestSchema.parse(request);
    const result = await invoke<Message>('set_message_streaming', { id: id, request: validated });

    logger.info('set_message_streaming completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('set_message_streaming failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Set token counts for a message
 *
 * @endpoint PATCH /api/messages/:id/tokens
 * @command set_message_tokens
 * @param id - Path parameter: id
 * @param inputTokens - Query parameter: input_tokens (optional)
 * @param outputTokens - Query parameter: output_tokens (optional)
 * @returns Promise resolving to Message
 * @throws Error if validation or query fails
 */
export async function setMessageTokens(
  id: string,
  inputTokens?: string,
  outputTokens?: string
): Promise<Message> {
  logger.debug('Calling set_message_tokens', { id });

  try {
    const result = await invoke<Message>('set_message_tokens', {
      id: id,
      input_tokens: inputTokens,
      output_tokens: outputTokens,
    });

    logger.info('set_message_tokens completed', {
      id: (result as unknown as Record<string, unknown>).id,
    });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('set_message_tokens failed', { error: errorMessage });
    throw error;
  }
}
