// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
//
// Generated by: scripts/generate-queries.ts
// Source: crates/openflow-contracts/src/endpoints/mod.rs
// Domain: processes
// Generated at: 2026-01-02T06:27:35.449Z
//
// This file contains type-safe query functions for the processes domain.
// Each function wraps a Tauri IPC command with validation and logging.
//
// To regenerate: pnpm generate:queries
//
// @see CLAUDE.md - Query Layer Patterns section
// =============================================================================

import type { ExecutionProcess, ResizeProcessRequest, SendProcessInputRequest } from '@openflow/generated';
import { resizeProcessRequestSchema, sendProcessInputRequestSchema } from '@openflow/validation';
import { createLogger } from '@openflow/utils';
import { invoke } from '../utils.js';

const logger = createLogger('queries:processes:generated');

/**
 * Get a process by ID
 *
 * @endpoint GET /api/processes/:id
 * @command get_process
 * @param id - Path parameter: id
 * @returns Promise resolving to ExecutionProcess
 * @throws Error if validation or query fails
 */
export async function getProcess(id: string): Promise<ExecutionProcess> {
  logger.debug('Calling get_process', { id });

  try {
    const result = await invoke<ExecutionProcess>('get_process', { id: id });

    logger.info('get_process completed', { id: (result as Record<string, unknown>).id });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('get_process failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Check if a process is running
 *
 * @endpoint GET /api/processes/:id/running
 * @command is_process_running
 * @param id - Path parameter: id
 * @returns Promise resolving to boolean
 * @throws Error if validation or query fails
 */
export async function isProcessRunning(id: string): Promise<boolean> {
  logger.debug('Calling is_process_running', { id });

  try {
    const result = await invoke<boolean>('is_process_running', { id: id });

    logger.info('is_process_running completed');

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('is_process_running failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Kill a running process
 *
 * @endpoint POST /api/processes/:id/kill
 * @command kill_process
 * @param id - Path parameter: id
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function killProcess(id: string): Promise<void> {
  logger.debug('Calling kill_process', { id });

  try {
    await invoke<void>('kill_process', { id: id });

    logger.info('kill_process completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('kill_process failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List processes, optionally filtered by chat
 *
 * @endpoint GET /api/processes
 * @command list_processes
 * @param chatId - Query parameter: chat_id (optional)
 * @returns Promise resolving to ExecutionProcess[]
 * @throws Error if validation or query fails
 */
export async function listProcesses(chatId?: string): Promise<ExecutionProcess[]> {
  logger.debug('Calling list_processes');

  try {
    const result = await invoke<ExecutionProcess[]>('list_processes', { chat_id: chatId });

    logger.info('list_processes completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_processes failed', { error: errorMessage });
    throw error;
  }
}

/**
 * List all running processes
 *
 * @endpoint GET /api/processes/running
 * @command list_running_processes
 * @returns Promise resolving to ExecutionProcess[]
 * @throws Error if validation or query fails
 */
export async function listRunningProcesses(): Promise<ExecutionProcess[]> {
  logger.debug('Calling list_running_processes');

  try {
    const result = await invoke<ExecutionProcess[]>('list_running_processes');

    logger.info('list_running_processes completed', { count: result.length });

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('list_running_processes failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Resize process PTY dimensions
 *
 * @endpoint POST /api/processes/:id/resize
 * @command resize_process
 * @param id - Path parameter: id
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function resizeProcess(id: string, request: ResizeProcessRequest): Promise<void> {
  logger.debug('Calling resize_process', { id });

  try {
    const validated = resizeProcessRequestSchema.parse(request);
    await invoke<void>('resize_process', { id: id, request: validated });

    logger.info('resize_process completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('resize_process failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Get count of running processes
 *
 * @endpoint GET /api/processes/count/running
 * @command running_process_count
 * @returns Promise resolving to number
 * @throws Error if validation or query fails
 */
export async function runningProcessCount(): Promise<number> {
  logger.debug('Calling running_process_count');

  try {
    const result = await invoke<number>('running_process_count');

    logger.info('running_process_count completed');

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('running_process_count failed', { error: errorMessage });
    throw error;
  }
}

/**
 * Send input to a process stdin
 *
 * @endpoint POST /api/processes/:id/input
 * @command send_process_input
 * @param id - Path parameter: id
 * @param request - Request body (validated with Zod)
 * @returns Promise resolving to void
 * @throws Error if validation or query fails
 */
export async function sendProcessInput(id: string, request: SendProcessInputRequest): Promise<void> {
  logger.debug('Calling send_process_input', { id });

  try {
    const validated = sendProcessInputRequestSchema.parse(request);
    await invoke<void>('send_process_input', { id: id, request: validated });

    logger.info('send_process_input completed successfully');
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error('send_process_input failed', { error: errorMessage });
    throw error;
  }
}
